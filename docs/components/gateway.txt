# captured_at: 2026-01-04T13:00:37.963415+00:00

# gateway/__init__.py


# gateway/api/__init__.py


# gateway/api/deps.py
# ==============================
# API Dependencies / Singletons
# ==============================
from __future__ import annotations

from functools import lru_cache

from core.config.loader import load_settings
from core.utils.product_loader import discover_products, register_enabled_products, ProductCatalog
from core.orchestrator.engine import OrchestratorEngine
from core.memory.router import MemoryRouter
from core.memory.tracing import Tracer


@lru_cache(maxsize=1)
def get_settings():
    return load_settings()


@lru_cache(maxsize=1)
def get_product_catalog() -> ProductCatalog:
    settings = get_settings()
    catalog = discover_products(settings)
    register_enabled_products(catalog, settings=settings)
    return catalog


@lru_cache(maxsize=1)
def get_memory_router() -> MemoryRouter:
    settings = get_settings()
    return MemoryRouter.from_settings(settings)


@lru_cache(maxsize=1)
def get_tracer() -> Tracer:
    settings = get_settings()
    mem = get_memory_router()
    return Tracer.from_settings(settings=settings, memory=mem)


def get_engine() -> OrchestratorEngine:
    settings = get_settings()
    get_product_catalog()  # keep product registry cached; engine must be per-request for isolation
    mem = get_memory_router()
    tracer = get_tracer()
    # Engine is request-scoped to avoid cross-session leakage.
    return OrchestratorEngine.from_settings(settings=settings, memory=mem, tracer=tracer)

# gateway/api/http_app.py
# ==============================
# FastAPI App Factory
# ==============================
from __future__ import annotations

from fastapi import FastAPI

from gateway.api.routes_run import router as run_router


def create_app() -> FastAPI:
    app = FastAPI(title="master", version="0.1.0")
    app.include_router(run_router, prefix="/api")

    @app.get("/health")
    def health() -> dict:
        return {"ok": True}

    return app

# ==============================
# ASGI entrypoint for uvicorn
# ==============================

app = create_app()

# gateway/api/routes_run.py
# ==============================
# Run & Product Routes
# ==============================
from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple
import json
from pathlib import Path

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.concurrency import run_in_threadpool
from fastapi.responses import FileResponse
from pydantic import BaseModel, Field

from core.contracts.run_schema import RunOperationResult
from core.orchestrator.engine import OrchestratorEngine
from core.utils.product_loader import ProductCatalog, ProductLoadError, ProductMeta
from gateway.api.deps import get_engine, get_product_catalog, get_memory_router, get_settings


router = APIRouter()
MAX_RUN_REQUEST_BYTES = 100 * 1024


def _estimate_payload_size(req: RunRequest) -> int:
    try:
        payload = json.dumps(req.payload, ensure_ascii=True, separators=(",", ":")).encode("utf-8")
    except Exception:
        payload = str(req.payload).encode("utf-8")
    text_bytes = (req.text or "").encode("utf-8")
    return len(payload) + len(text_bytes)


class RunRequest(BaseModel):
    payload: Dict[str, Any] = Field(default_factory=dict)
    text: Optional[str] = Field(default=None, description="Optional plain-text input for intent-driven flows.")


class ResumeRequest(BaseModel):
    decision: str = Field(default="APPROVED", description="Decision applied to the pending approval.")
    resolved_by: Optional[str] = Field(default=None, description="Optional reviewer identifier.")
    comment: Optional[str] = Field(default=None, description="Optional reviewer comment.")
    approval_payload: Dict[str, Any] = Field(default_factory=dict)
    user_input_response: Dict[str, Any] = Field(default_factory=dict)


def _ok(data: Dict[str, Any], *, meta: Dict[str, Any] | None = None) -> Dict[str, Any]:
    return {"ok": True, "data": data, "error": None, "meta": meta or {}}


def _error(
    *,
    http_status: int,
    code: str,
    message: str,
    details: Dict[str, Any] | None = None,
    meta: Dict[str, Any] | None = None,
) -> Dict[str, Any]:
    payload = {
        "ok": False,
        "data": None,
        "error": {"code": code, "message": message, "details": details or {}},
        "meta": meta or {},
    }
    raise HTTPException(status_code=http_status, detail=payload)


def _serialize_error(err: ProductLoadError) -> Dict[str, Any]:
    return {"product": err.product, "path": err.path, "message": err.message}


def _serialize_product(
    meta: ProductMeta,
    errors: List[ProductLoadError],
    config: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    per_product_errors = [_serialize_error(err) for err in errors if err.product == meta.name]
    return {
        "name": meta.name,
        "display_name": meta.display_name,
        "description": meta.description,
        "version": meta.version,
        "default_flow": meta.default_flow,
        "expose_api": meta.expose_api,
        "ui_enabled": meta.ui_enabled,
        "flows": meta.flows,
        "ui": meta.ui.model_dump(),
        "enabled": meta.enabled,
        "errors": per_product_errors,
        "config": config or {},
    }


def _product_errors(catalog: ProductCatalog, product: str) -> List[Dict[str, Any]]:
    return [_serialize_error(err) for err in catalog.errors if err.product == product]


def _ensure_product_ready(catalog: ProductCatalog, product: str) -> Tuple[ProductMeta, List[str]]:
    meta = catalog.products.get(product)
    if meta is None:
        _error(
            http_status=status.HTTP_404_NOT_FOUND,
            code="product_not_found",
            message=f"Unknown product '{product}'.",
        )
    if not meta.enabled:
        _error(
            http_status=status.HTTP_404_NOT_FOUND,
            code="product_disabled",
            message=f"Product '{product}' is not enabled.",
        )
    errs = _product_errors(catalog, product)
    if errs:
        _error(
            http_status=status.HTTP_503_SERVICE_UNAVAILABLE,
            code="product_unavailable",
            message=f"Product '{product}' failed to load.",
            details={"errors": errs},
        )
    flows = catalog.flows.get(product, [])
    return meta, flows


def _ensure_flow(meta: ProductMeta, flows: List[str], flow: str) -> None:
    if flow not in flows:
        _error(
            http_status=status.HTTP_404_NOT_FOUND,
            code="flow_not_found",
            message=f"Unknown flow '{flow}' for product '{meta.name}'.",
            details={"available_flows": flows},
        )


def _respond(result: RunOperationResult, *, meta: Dict[str, Any] | None = None) -> Dict[str, Any]:
    if result.ok:
        return _ok(result.data or {}, meta=meta)
    error = result.error
    if error is None:
        _error(
            http_status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            code="unknown_error",
            message="Unknown failure.",
            meta=meta,
        )
    http_status = status.HTTP_404_NOT_FOUND if error.code == "not_found" else status.HTTP_400_BAD_REQUEST
    _error(
        http_status=http_status,
        code=error.code,
        message=error.message,
        details=error.details,
        meta=meta,
    )


@router.get("/products")
def list_products(catalog: ProductCatalog = Depends(get_product_catalog)) -> Dict[str, Any]:
    products = [
        _serialize_product(
            meta,
            catalog.errors,
            config=catalog.configs.get(meta.name).model_dump() if catalog.configs.get(meta.name) else {},
        )
        for meta in sorted(catalog.products.values(), key=lambda m: m.name)
    ]
    orphan_errors = [_serialize_error(err) for err in catalog.errors if err.product not in catalog.products]
    return _ok({"products": products, "errors": orphan_errors})


@router.get("/products/{product}/flows")
def list_flows(
    product: str,
    catalog: ProductCatalog = Depends(get_product_catalog),
) -> Dict[str, Any]:
    meta, flows = _ensure_product_ready(catalog, product)
    return _ok({"product": meta.name, "flows": flows, "default_flow": meta.default_flow})

@router.get("/runs")
def list_runs(
    limit: int = 50,
    offset: int = 0,
    memory=Depends(get_memory_router),
) -> Dict[str, Any]:
    runs = [r.model_dump() for r in memory.list_runs(limit=limit, offset=offset)]
    return _ok({"runs": runs})


@router.get("/approvals")
def list_approvals(
    limit: int = 50,
    offset: int = 0,
    memory=Depends(get_memory_router),
) -> Dict[str, Any]:
    approvals = [a.model_dump() for a in memory.list_pending_approvals(limit=limit, offset=offset)]
    return _ok({"approvals": approvals})


@router.get("/output/{product}/{run_id}/{filename}")
def get_output_file(
    product: str,
    run_id: str,
    filename: str,
    settings=Depends(get_settings),
) -> FileResponse:
    repo_root = settings.repo_root_path()
    observability_dir = Path(settings.app.paths.observability_dir)
    observability_root = observability_dir if observability_dir.is_absolute() else (repo_root / observability_dir)
    base = observability_root / product / run_id / "output"
    target = (base / filename).resolve()
    if not str(target).startswith(str(base.resolve())):
        _error(http_status=status.HTTP_400_BAD_REQUEST, code="invalid_path", message="Invalid output path.")
    if not target.exists():
        _error(http_status=status.HTTP_404_NOT_FOUND, code="not_found", message="Output file not found.")
    return FileResponse(target)

@router.post("/run/{product}/{flow}")
async def run_flow(
    product: str,
    flow: str,
    req: RunRequest,
    engine: OrchestratorEngine = Depends(get_engine),
    catalog: ProductCatalog = Depends(get_product_catalog),
) -> Dict[str, Any]:
    if _estimate_payload_size(req) > MAX_RUN_REQUEST_BYTES:
        _error(
            http_status=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
            code="payload_too_large",
            message=f"Payload exceeds {MAX_RUN_REQUEST_BYTES} bytes limit.",
        )
    meta, flows = _ensure_product_ready(catalog, product)
    _ensure_flow(meta, flows, flow)
    payload = req.payload
    if not payload and req.text is not None:
        intent_field = "keyword"
        ui = meta.ui
        if ui and getattr(ui, "intent", None) and ui.intent.enabled:
            intent_field = ui.intent.field or intent_field
        payload = {intent_field: req.text}
    res = await run_in_threadpool(engine.run_flow, product=product, flow=flow, payload=payload)
    return _respond(res, meta={"product": product, "flow": flow})


@router.get("/run/{run_id}")
async def get_run(
    run_id: str,
    engine: OrchestratorEngine = Depends(get_engine),
) -> Dict[str, Any]:
    res = await run_in_threadpool(engine.get_run, run_id=run_id)
    return _respond(res, meta={"run_id": run_id})


@router.post("/resume_run/{run_id}")
async def resume_run(
    run_id: str,
    req: ResumeRequest,
    engine: OrchestratorEngine = Depends(get_engine),
) -> Dict[str, Any]:
    res = await run_in_threadpool(
        engine.resume_run,
        run_id=run_id,
        approval_payload=req.approval_payload,
        user_input_response=req.user_input_response,
        decision=req.decision,
        resolved_by=req.resolved_by,
        comment=req.comment,
    )
    return _respond(res, meta={"run_id": run_id, "decision": req.decision})

# gateway/cli/__init__.py


# gateway/cli/main.py
# ==============================
# CLI Entrypoint
# ==============================
"""
CLI for master/ platform.

Supported commands:
  master list-products
  master list-flows --product hello_world
  master run --product hello_world --flow hello_world --payload '{"keyword":"hi"}'
  master run --product hello_world --flow hello_world --payload-file payload.json
  master status --run-id run_123
  master approvals
  master resume --run-id run_123 --approve --payload '{"approved": true}'
"""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from core.agents.registry import AgentRegistry
from core.config.loader import load_settings
from core.memory.router import MemoryRouter
from core.orchestrator.engine import OrchestratorEngine
from core.tools.registry import ToolRegistry
from core.utils.product_loader import (
    ProductCatalog,
    discover_products,
    register_enabled_products,
)


def _json_load(text: str) -> Dict[str, Any]:
    try:
        value = json.loads(text)
    except Exception as exc:  # pragma: no cover - defensive
        raise SystemExit(f"Invalid JSON payload: {exc}") from exc
    if not isinstance(value, dict):
        raise SystemExit("JSON payload must be an object.")
    return value


def _load_payload_arg(payload: Optional[str], payload_file: Optional[str]) -> Dict[str, Any]:
    if payload and payload_file:
        raise SystemExit("Provide only one of --payload or --payload-file.")
    if payload_file:
        text = Path(payload_file).read_text(encoding="utf-8")
        return _json_load(text)
    if payload:
        return _json_load(payload)
    return {}


def _print_json(obj: Any) -> None:
    print(json.dumps(obj, indent=2, ensure_ascii=False, default=str))


def _catalog_product(catalog: ProductCatalog, product: str) -> Tuple[Any, List[str]]:
    meta = catalog.products.get(product)
    if meta is None:
        raise SystemExit(f"Unknown product '{product}'. Run `list-products` to inspect enabled packs.")
    if not meta.enabled:
        raise SystemExit(f"Product '{product}' is not enabled. Update configs/products.yaml to enable it.")
    errors = [err for err in catalog.errors if err.product == product]
    if errors:
        raise SystemExit(f"Product '{product}' is unavailable: {errors[0].message} ({errors[0].path})")
    return meta, catalog.flows.get(product, [])


def cmd_list_products(catalog: ProductCatalog) -> int:
    products = {
        name: {
            "display_name": meta.display_name,
            "description": meta.description,
            "default_flow": meta.default_flow,
            "enabled": meta.enabled,
            "flows": catalog.flows.get(name, []),
            "errors": [
                {"path": err.path, "message": err.message}
                for err in catalog.errors
                if err.product == name
            ],
        }
        for name, meta in sorted(catalog.products.items())
    }
    _print_json({"products": products})
    return 0


def cmd_list_flows(catalog: ProductCatalog, product: str) -> int:
    _, flows = _catalog_product(catalog, product)
    _print_json({"product": product, "flows": flows})
    return 0


def cmd_run(
    engine: OrchestratorEngine,
    catalog: ProductCatalog,
    *,
    product: str,
    flow: str,
    payload: Dict[str, Any],
    requested_by: Optional[str],
) -> int:
    _, flows = _catalog_product(catalog, product)
    if flow not in flows:
        raise SystemExit(f"Unknown flow '{flow}' for product '{product}'. Available: {', '.join(flows)}")
    res = engine.run_flow(product=product, flow=flow, payload=payload, requested_by=requested_by)
    _print_json(res.model_dump())
    return 0 if res.ok else 1


def cmd_status(engine: OrchestratorEngine, *, run_id: str) -> int:
    res = engine.get_run(run_id=run_id)
    _print_json(res.model_dump())
    return 0 if res.ok else 1


def cmd_resume(
    engine: OrchestratorEngine,
    *,
    run_id: str,
    decision: str,
    payload: Dict[str, Any],
    resolved_by: Optional[str],
    comment: Optional[str],
) -> int:
    res = engine.resume_run(
        run_id=run_id,
        decision=decision,
        approval_payload=payload,
        resolved_by=resolved_by,
        comment=comment,
    )
    _print_json(res.model_dump())
    return 0 if res.ok else 1


def cmd_approvals(memory: MemoryRouter) -> int:
    approvals = [
        approval.model_dump()
        for approval in memory.list_pending_approvals(limit=100, offset=0)
    ]
    _print_json({"approvals": approvals})
    return 0


def main(argv: Optional[List[str]] = None) -> int:
    ap = argparse.ArgumentParser(prog="master")
    sub = ap.add_subparsers(dest="cmd", required=True)

    sub.add_parser("list-products")

    ap_flows = sub.add_parser("list-flows")
    ap_flows.add_argument("--product", required=True)

    ap_run = sub.add_parser("run")
    ap_run.add_argument("--product", required=True)
    ap_run.add_argument("--flow", required=True)
    ap_run.add_argument("--payload", help="JSON object string", default=None)
    ap_run.add_argument("--payload-file", help="Path to JSON file with payload", default=None)
    ap_run.add_argument("--requested-by", help="Optional requester identifier", default=None)

    ap_status = sub.add_parser("status")
    ap_status.add_argument("--run-id", required=True)

    ap_get = sub.add_parser("get-run")
    ap_get.add_argument("--run-id", required=True)

    ap_approvals = sub.add_parser("approvals")

    ap_resume = sub.add_parser("resume")
    ap_resume.add_argument("--run-id", required=True)
    decision_group = ap_resume.add_mutually_exclusive_group()
    decision_group.add_argument("--approve", action="store_true", help="Approve the pending run")
    decision_group.add_argument("--reject", action="store_true", help="Reject the pending run")
    ap_resume.add_argument("--payload", help="JSON object string", default=None)
    ap_resume.add_argument("--payload-file", help="Path to JSON file with approval payload", default=None)
    ap_resume.add_argument("--comment", help="Optional approval comment", default=None)
    ap_resume.add_argument("--resolved-by", help="Optional reviewer identifier", default=None)

    args = ap.parse_args(argv)

    settings = load_settings()
    catalog = discover_products(settings)
    AgentRegistry.clear()
    ToolRegistry.clear()
    register_enabled_products(catalog, settings=settings)
    engine = OrchestratorEngine.from_settings(settings)
    memory = engine.memory

    if args.cmd == "list-products":
        return cmd_list_products(catalog)
    if args.cmd == "list-flows":
        return cmd_list_flows(catalog, args.product)
    if args.cmd == "run":
        payload = _load_payload_arg(args.payload, args.payload_file)
        return cmd_run(
            engine,
            catalog,
            product=args.product,
            flow=args.flow,
            payload=payload,
            requested_by=args.requested_by,
        )
    if args.cmd in {"status", "get-run"}:
        return cmd_status(engine, run_id=args.run_id)
    if args.cmd == "approvals":
        return cmd_approvals(memory)
    if args.cmd == "resume":
        decision = "REJECTED" if args.reject else "APPROVED"
        payload = _load_payload_arg(args.payload, args.payload_file)
        return cmd_resume(
            engine,
            run_id=args.run_id,
            decision=decision,
            payload=payload,
            resolved_by=args.resolved_by,
            comment=args.comment,
        )

    raise SystemExit("Unknown command")


if __name__ == "__main__":
    raise SystemExit(main())

# gateway/ui/__init__.py


# gateway/ui/platform_app.py
# ==============================
# Platform UI (Streamlit) - v1 Control Center
# ==============================
"""
Streamlit-based Platform Control Center for master/.

Capabilities:
- Discover enabled products + flows via /api/products
- Trigger flow runs with JSON payloads
- View run history + details via /api/run/{run_id}
- Inspect and resolve pending approvals via POST /api/resume_run/{run_id}

UI architecture:
- Home: product/flow overview
- Run: product+flow selection + payload editor
- Runs: history + detail view
- Approvals: list pending approvals + actions

All actions go through the Gateway API. No direct core imports besides settings.
"""

from __future__ import annotations

import json
import shutil
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path
import sys
import time

import requests
import streamlit as st
import yaml

REPO_ROOT = Path(__file__).resolve().parents[2]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from core.config.loader import load_settings


@dataclass(frozen=True)
class ApiResponse:
    ok: bool
    body: Optional[Dict[str, Any]]
    error: Optional[str]


class ApiClient:
    def __init__(self, base_url: str, timeout: int = 15) -> None:
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout

    def _request(self, method: str, path: str, payload: Optional[Dict[str, Any]] = None) -> ApiResponse:
        url = f"{self.base_url}{path}"
        try:
            resp = getattr(requests, method.lower())(url, json=payload, timeout=self.timeout)
        except requests.RequestException as exc:
            return ApiResponse(ok=False, body=None, error=str(exc))

        try:
            body = resp.json()
        except ValueError:
            body = None

        if not resp.ok:
            return ApiResponse(ok=False, body=body, error=body.get("error", {}).get("message") if body else resp.text)

        if isinstance(body, dict) and not body.get("ok", True):
            return ApiResponse(ok=False, body=body, error=body.get("error", {}).get("message", "API error"))

        return ApiResponse(ok=True, body=body, error=None)

    def list_products(self) -> ApiResponse:
        return self._request("GET", "/api/products")

    def list_flows(self, product: str) -> ApiResponse:
        return self._request("GET", f"/api/products/{product}/flows")

    def run_flow(self, product: str, flow: str, payload: Dict[str, Any]) -> ApiResponse:
        return self._request("POST", f"/api/run/{product}/{flow}", {"payload": payload})

    def get_run(self, run_id: str) -> ApiResponse:
        return self._request("GET", f"/api/run/{run_id}")

    def resume_run(
        self,
        run_id: str,
        *,
        decision: str,
        approval_payload: Optional[Dict[str, Any]] = None,
        comment: Optional[str] = None,
        user_input_response: Optional[Dict[str, Any]] = None,
    ) -> ApiResponse:
        return self._request(
            "POST",
            f"/api/resume_run/{run_id}",
            {
                "decision": decision,
                "approval_payload": approval_payload or {},
                "comment": comment or "",
                "user_input_response": user_input_response or {},
            },
        )

    def list_runs(self) -> ApiResponse:
        return self._request("GET", "/api/runs")

    def list_approvals(self) -> ApiResponse:
        return self._request("GET", "/api/approvals")


def _api_base_url(settings: Any) -> str:
    candidate = getattr(getattr(settings, "app", None), "api_base_url", None)
    if isinstance(candidate, str) and candidate.strip():
        return candidate.strip().rstrip("/")
    host = getattr(settings.app, "host", "localhost")
    port = getattr(settings.app, "port", 8000)
    scheme = "https" if getattr(settings.app, "debug", False) is False else "http"
    return f"{scheme}://{host}:{port}"

def _resolve_path(path_str: str) -> Path:
    path = Path(path_str)
    return path if path.is_absolute() else (REPO_ROOT / path)


def _observability_root(settings: Any | None = None) -> Path:
    resolved = settings or load_settings()
    path = Path(resolved.app.paths.observability_dir)
    return path if path.is_absolute() else (resolved.repo_root_path() / path)


def _save_uploaded_files(
    uploaded_files: List[Any],
    *,
    upload_id: str,
) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
    file_refs: List[Dict[str, Any]] = []
    items: List[Dict[str, Any]] = []
    for item in uploaded_files:
        name = item.name
        suffix = Path(name).suffix.lower().lstrip(".")
        if suffix not in {"csv", "pdf"}:
            continue
        file_type = suffix
        file_id = f"{upload_id}_{name}"
        file_refs.append({"file_id": file_id, "file_type": file_type, "name": name})
        items.append({"name": name, "file_type": file_type, "content": item.getbuffer().tobytes()})
    return file_refs, items


def _materialize_run_dirs(observability_root: Path, *, product: str, run_id: str) -> Dict[str, Path]:
    base = observability_root / product / run_id
    paths = {
        "base": base,
        "input": base / "input",
        "runtime": base / "runtime",
        "output": base / "output",
    }
    for path in paths.values():
        path.mkdir(parents=True, exist_ok=True)
    return paths


def _clear_dir(path: Path) -> None:
    if not path.exists():
        return
    for entry in path.iterdir():
        if entry.is_dir():
            for child in entry.iterdir():
                if child.is_dir():
                    for grandchild in child.iterdir():
                        if grandchild.is_dir():
                            shutil.rmtree(grandchild, ignore_errors=True)
                        else:
                            grandchild.unlink(missing_ok=True)
                else:
                    child.unlink(missing_ok=True)
            shutil.rmtree(entry, ignore_errors=True)
        else:
            entry.unlink(missing_ok=True)


def _materialize_upload_dirs(observability_root: Path, *, product: str, upload_id: str) -> Path:
    staging_dir = REPO_ROOT / "products" / product / "staging" / "input"
    staging_dir.mkdir(parents=True, exist_ok=True)
    return staging_dir


def _write_inputs_to_uploads(
    observability_root: Path,
    *,
    product: str,
    upload_id: str,
    items: List[Dict[str, Any]],
) -> None:
    if not items:
        return
    upload_dir = _materialize_upload_dirs(observability_root, product=product, upload_id=upload_id)
    _clear_dir(upload_dir)
    output_dir = REPO_ROOT / "products" / product / "staging" / "output"
    output_dir.mkdir(parents=True, exist_ok=True)
    _clear_dir(output_dir)
    for item in items:
        target = upload_dir / item["name"]
        if target.exists():
            continue
        target.write_bytes(item["content"])


def _write_inputs_to_run(
    observability_root: Path,
    *,
    product: str,
    run_id: str,
    items: List[Dict[str, Any]],
) -> None:
    if not items:
        return
    run_input_dir = _materialize_run_dirs(observability_root, product=product, run_id=run_id)["input"]
    for item in items:
        target = run_input_dir / item["name"]
        if target.exists():
            continue
        target.write_bytes(item["content"])


def _load_run_events(observability_root: Path, *, product: str, run_id: str) -> List[Dict[str, Any]]:
    runtime_path = observability_root / product / run_id / "runtime" / "events.jsonl"
    events: List[Dict[str, Any]] = []
    if not runtime_path.exists():
        return events
    for line in runtime_path.read_text(encoding="utf-8").splitlines():
        if not line.strip():
            continue
        try:
            events.append(json.loads(line))
        except Exception:
            continue
    return events


def _summarize_events(events: List[Dict[str, Any]]) -> Dict[str, Any]:
    if not events:
        return {"status": "UNKNOWN", "started_at": 0}
    events_sorted = sorted(events, key=lambda e: e.get("ts", 0))
    started_at = events_sorted[0].get("ts", 0)
    status = "RUNNING"
    for event in reversed(events_sorted):
        kind = event.get("kind")
        if kind == "run_completed":
            status = "COMPLETED"
            break
        if kind in {"run_failed", "run_rejected"}:
            status = "FAILED"
            break
        if kind == "pending_human":
            status = "PENDING_HUMAN"
            break
        if kind == "user_input_requested":
            status = "PENDING_USER_INPUT"
            break
    return {"status": status, "started_at": started_at}


def _list_observed_runs(observability_root: Path) -> List[Dict[str, Any]]:
    runs: List[Dict[str, Any]] = []
    if not observability_root.exists():
        return runs
    for product_dir in sorted(observability_root.glob("*")):
        if not product_dir.is_dir():
            continue
        for run_dir in sorted(product_dir.glob("*")):
            if not run_dir.is_dir():
                continue
            events = _load_run_events(observability_root, product=product_dir.name, run_id=run_dir.name)
            if not events:
                continue
            events_sorted = sorted(events, key=lambda e: e.get("ts", 0))
            summary = _summarize_events(events)
            runs.append(
                {
                    "run_id": run_dir.name,
                    "product": product_dir.name,
                    "flow": events_sorted[0].get("flow", "unknown") if events_sorted else "unknown",
                    "started_at": summary["started_at"],
                    "status": summary["status"],
                }
            )
    return runs


def _safe_json_loads(value: str) -> Tuple[bool, Dict[str, Any], str]:
    try:
        parsed = json.loads(value or "{}")
        if not isinstance(parsed, dict):
            return False, {}, "JSON must be an object (e.g., {\"k\": \"v\"})"
        return True, parsed, ""
    except Exception as exc:
        return False, {}, str(exc)


def _pretty(obj: Any) -> str:
    return json.dumps(obj, indent=2, ensure_ascii=False, default=str)


def _append_history(run_id: str) -> None:
    history = st.session_state.setdefault("run_history", [])
    if run_id in history:
        history.remove(run_id)
    history.append(run_id)


def _get_product_record(products: List[Dict[str, Any]], name: str) -> Dict[str, Any]:
    for product in products:
        if product.get("name") == name:
            return product
    return {}


def _get_product_config(product: Dict[str, Any]) -> Dict[str, Any]:
    config = product.get("config") or {}
    return config if isinstance(config, dict) else {}


def _resolve_input_spec(config: Dict[str, Any]) -> Dict[str, Any]:
    metadata = config.get("metadata") if isinstance(config, dict) else None
    if not isinstance(metadata, dict):
        metadata = {}
    ui = metadata.get("ui")
    if isinstance(ui, dict):
        inputs = ui.get("inputs")
        if isinstance(inputs, dict):
            return inputs
    inputs = metadata.get("inputs")
    if isinstance(inputs, dict):
        return inputs
    for value in metadata.values():
        if isinstance(value, dict) and isinstance(value.get("inputs"), dict):
            return value.get("inputs") or {}
    return {}


def _resolve_intent_spec(config: Dict[str, Any]) -> Dict[str, Any]:
    metadata = config.get("metadata") if isinstance(config, dict) else None
    if not isinstance(metadata, dict):
        metadata = {}
    ui = metadata.get("ui")
    if isinstance(ui, dict):
        intent = ui.get("intent")
        if isinstance(intent, dict):
            return intent
    intent = metadata.get("intent")
    if isinstance(intent, dict):
        return intent
    for value in metadata.values():
        if isinstance(value, dict) and isinstance(value.get("intent"), dict):
            return value.get("intent") or {}
    return {}


def _render_product_summary(products: List[Dict[str, Any]]) -> None:
    st.subheader("Products")
    if not products:
        st.info("No enabled products were discovered.")
        return

    for product in sorted(products, key=lambda p: p["name"]):
        header = f"{product['display_name']} ({product['name']})"
        with st.expander(header, expanded=False):
            st.write(product.get("description") or "No description provided.")
            st.markdown("**Flows**")
            flows = sorted(product.get("flows", []))
            st.write(", ".join(flows) if flows else "_No flows defined yet_")


def _render_run_history(*, observability_root: Path) -> None:
    st.subheader("Run history")
    runs = _list_observed_runs(observability_root)
    if not runs:
        st.info("No runs have been recorded yet.")
        return
    runs = sorted(runs, key=lambda r: r.get("started_at", 0), reverse=True)

    for run in runs:
        run_id = run.get("run_id")
        product = run.get("product", "unknown")
        flow = run.get("flow", "unknown")
        status = run.get("status", "UNKNOWN")
        title = f"{run_id} — {product}/{flow} ({status})"
        with st.expander(title, expanded=False):
            st.write(f"Started: {run.get('started_at')}")
            events = _load_run_events(observability_root, product=product, run_id=run_id)
            st.write(f"Events: {len(events)}")
            approvals_from_output: List[Dict[str, Any]] = []
            output_dir = observability_root / product / run_id / "output"
            base_url = _api_base_url(load_settings())
            if output_dir.exists() and output_dir.is_dir():
                response_path = output_dir / "response.json"
                if response_path.exists():
                    try:
                        response_payload = json.loads(response_path.read_text(encoding="utf-8"))
                        approvals_from_output = response_payload.get("approvals") or []
                    except Exception:
                        approvals_from_output = []
                output_files = sorted([p for p in output_dir.iterdir() if p.is_file()])
                if output_files:
                    st.markdown("**Outputs**")
                    for output_file in output_files:
                        st.markdown(
                            f"[Download {output_file.name}]({base_url}/api/output/{product}/{run_id}/{output_file.name})"
                        )
            if events:
                step_state: Dict[str, Dict[str, str]] = {}
                approvals: List[Dict[str, Any]] = []
                for event in events:
                    step_id = event.get("step_id")
                    if not step_id:
                        continue
                    kind = event.get("kind")
                    if kind == "step_started":
                        step_state[step_id] = {"step_id": step_id, "status": "RUNNING"}
                    elif kind == "step_completed":
                        step_state[step_id] = {"step_id": step_id, "status": "COMPLETED"}
                    elif kind == "step_failed":
                        step_state[step_id] = {"step_id": step_id, "status": "FAILED"}
                    elif kind == "pending_human":
                        step_state[step_id] = {"step_id": step_id, "status": "PENDING_HUMAN"}
                    elif kind == "user_input_requested":
                        step_state[step_id] = {"step_id": step_id, "status": "PENDING_USER_INPUT"}
                    elif kind == "user_input_received":
                        step_state[step_id] = {"step_id": step_id, "status": "COMPLETED"}
                    if kind in {"run_resumed", "run_rejected"}:
                        step_state[step_id] = {
                            "step_id": step_id,
                            "status": "APPROVED" if kind == "run_resumed" else "REJECTED",
                        }
                        approvals.append(
                            {
                                "time": event.get("ts"),
                                "decision": (event.get("payload") or {}).get("decision"),
                                "comment": (event.get("payload") or {}).get("comment") or "",
                                "step_id": step_id,
                            }
                        )
                if step_state:
                    st.table(list(step_state.values()))
                if approvals_from_output or approvals:
                    st.markdown("**Approvals**")
                    for approval in approvals_from_output:
                        decision = approval.get("decision")
                        comment = approval.get("comment") or ""
                        step_id = approval.get("step_id")
                        resolved_at = approval.get("resolved_at")
                        line = f"{resolved_at} • {step_id} • {decision}"
                        if comment:
                            line = f"{line} — {comment}"
                        st.write(line)
                    for approval in approvals:
                        decision = approval.get("decision")
                        comment = approval.get("comment")
                        step_id = approval.get("step_id")
                        ts = approval.get("time")
                        line = f"{ts} • {step_id} • {decision}"
                        if comment:
                            line = f"{line} — {comment}"
                        st.write(line)


def _render_approvals(client: ApiClient) -> None:
    st.subheader("Pending approvals")
    st.markdown(
        """
<style>
button[kind="primary"] { background-color: #2e7d32 !important; color: white !important; }
button[kind="secondary"] { background-color: #c62828 !important; color: white !important; }
</style>
""",
        unsafe_allow_html=True,
    )
    approvals_resp = client.list_approvals()
    if not approvals_resp.ok or not approvals_resp.body:
        st.warning(f"Unable to load approvals: {approvals_resp.error or approvals_resp.body}")
        return
    approvals = approvals_resp.body["data"].get("approvals", [])
    if not approvals:
        st.info("No pending approvals.")
        return

    options = []
    for approval in approvals:
        label = f"{approval['run_id']} — {approval['product']}/{approval['flow']} ({approval['step_id']})"
        options.append((label, approval))

    selection = st.selectbox("Select pending run", options, format_func=lambda item: item[0])
    approval = selection[1]
    run_id = approval["run_id"]
    st.write(f"Selected run: {run_id}")
    events = _load_run_events(_observability_root(), product=approval["product"], run_id=run_id)
    decisions: List[Dict[str, Any]] = []
    for event in events:
        kind = event.get("kind")
        if kind in {"run_resumed", "run_rejected"}:
            decisions.append(
                {
                    "time": event.get("ts"),
                    "decision": (event.get("payload") or {}).get("decision"),
                    "comment": (event.get("payload") or {}).get("comment") or "",
                    "step_id": event.get("step_id"),
                }
            )
    if decisions:
        st.markdown("**Decision history**")
        for entry in decisions:
            line = f"{entry.get('time')} • {entry.get('step_id')} • {entry.get('decision')}"
            if entry.get("comment"):
                line = f"{line} — {entry.get('comment')}"
            st.write(line)
    else:
        st.caption("Decision and notes will appear here after approval or rejection.")
    payload = approval.get("payload") or {}
    summary = payload.get("summary") if isinstance(payload, dict) else None
    instructions = payload.get("instructions") if isinstance(payload, dict) else None
    actions = payload.get("actions") if isinstance(payload, dict) else None
    approval_context = payload.get("approval_context") if isinstance(payload, dict) else None
    intent = payload.get("intent") if isinstance(payload, dict) else None
    if intent:
        st.markdown("**User intent**")
        st.write(intent)
    if summary:
        st.markdown("**Approval summary**")
        st.write(summary)
    if approval_context:
        st.markdown("**Approval needed for**")
        reason = approval_context.get("reason") if isinstance(approval_context, dict) else None
        step_name = approval_context.get("step_name") if isinstance(approval_context, dict) else None
        decision_notes = approval_context.get("decision_notes") if isinstance(approval_context, dict) else None
        recommended = approval_context.get("recommended_action") if isinstance(approval_context, dict) else None
        if step_name:
            st.write(f"Step: {step_name}")
        if reason:
            st.write(reason)
        if decision_notes:
            st.markdown("**Decision notes**")
            for note in decision_notes:
                st.write(f"- {note}")
        if recommended:
            st.markdown("**System recommendation**")
            st.write(recommended)
    if actions:
        st.markdown("**Actions taken**")
        if isinstance(actions, list):
            for action in actions:
                st.write(f"- {action}")
        else:
            st.write(actions)
    if payload:
        with st.expander("Approval context (advanced)"):
            st.code(_pretty(payload), language="json")
    comment = st.text_area("Reviewer comments", value="", height=120, help="Optional guidance for re-planning.")
    approval_payload = {"approved": True}

    col1, col2 = st.columns(2)
    with col1:
        if st.button("Approve", type="primary", disabled=(not run_id.strip())):
            resp = client.resume_run(
                run_id.strip(),
                decision="APPROVED",
                approval_payload=approval_payload,
                comment=comment or None,
            )
            if resp.ok:
                st.success(f"Run resumed (approved): {run_id.strip()}")
                _append_history(run_id.strip())
                st.rerun()
            else:
                st.error(f"Failed to resume run: {resp.error or resp.body}")
    with col2:
        if st.button("Reject", type="secondary", disabled=(not run_id.strip())):
            reject_payload = {"approved": False}
            resp = client.resume_run(
                run_id.strip(),
                decision="REJECTED",
                approval_payload=reject_payload,
                comment=comment or None,
            )
            if resp.ok:
                st.success(f"Run resumed (rejected): {run_id.strip()}")
                _append_history(run_id.strip())
                st.rerun()
            else:
                st.error(f"Failed to reject run: {resp.error or resp.body}")


def _pending_user_inputs_from_events(events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    pending: Dict[str, Dict[str, Any]] = {}
    for event in sorted(events, key=lambda e: e.get("ts", 0)):
        kind = event.get("kind")
        step_id = event.get("step_id")
        if kind == "user_input_requested" and step_id:
            payload = event.get("payload") or {}
            form_id = payload.get("form_id")
            if isinstance(form_id, str):
                pending[step_id] = {
                    "step_id": step_id,
                    "form_id": form_id,
                    "payload": payload,
                    "ts": event.get("ts", 0),
                }
        elif kind == "user_input_received" and step_id:
            pending.pop(step_id, None)
        elif kind in {"run_completed", "run_failed", "run_rejected"}:
            pending.clear()
    return list(pending.values())


def _load_flow_definition(product: str, flow: str) -> Optional[Dict[str, Any]]:
    flow_path = REPO_ROOT / "products" / product / "flows" / f"{flow}.yaml"
    if not flow_path.exists():
        return None
    try:
        return yaml.safe_load(flow_path.read_text(encoding="utf-8")) or {}
    except Exception:
        return None


def _get_user_input_config(flow_def: Dict[str, Any], form_id: str) -> Optional[Dict[str, Any]]:
    steps = flow_def.get("steps") if isinstance(flow_def, dict) else None
    if not isinstance(steps, list):
        return None
    for step in steps:
        if not isinstance(step, dict):
            continue
        if step.get("type") != "user_input":
            continue
        params = step.get("params") if isinstance(step.get("params"), dict) else {}
        if params.get("form_id") == form_id:
            return params
    return None


def _render_user_inputs(client: ApiClient) -> None:
    st.subheader("Pending user inputs")
    observability_root = _observability_root()
    pending_inputs: List[Dict[str, Any]] = []
    if observability_root.exists():
        for product_dir in sorted(observability_root.glob("*")):
            if not product_dir.is_dir():
                continue
            for run_dir in sorted(product_dir.glob("*")):
                if not run_dir.is_dir():
                    continue
                events = _load_run_events(observability_root, product=product_dir.name, run_id=run_dir.name)
                if not events:
                    continue
                flow = events[0].get("flow") or ""
                pending = _pending_user_inputs_from_events(events)
                for item in pending:
                    item.update({"product": product_dir.name, "run_id": run_dir.name, "flow": flow})
                    pending_inputs.append(item)

    if not pending_inputs:
        st.info("No pending user inputs.")
        return

    options = []
    for item in pending_inputs:
        label = f"{item['run_id']} — {item['product']}/{item['flow']} ({item['step_id']})"
        options.append((label, item))

    selection = st.selectbox("Select pending input", options, format_func=lambda item: item[0])
    selected = selection[1]
    run_id = selected["run_id"]
    product = selected["product"]
    flow = selected["flow"]
    form_id = selected["form_id"]
    payload = selected.get("payload") or {}

    st.write(f"Selected run: {run_id}")
    title = payload.get("title") or form_id
    st.markdown(f"**{title}**")
    description = payload.get("description")
    if description:
        st.write(description)

    flow_def = _load_flow_definition(product, flow) or {}
    form_config = _get_user_input_config(flow_def, form_id) or {}
    schema = form_config.get("schema") if isinstance(form_config.get("schema"), dict) else {}
    defaults = form_config.get("defaults") if isinstance(form_config.get("defaults"), dict) else {}
    required = form_config.get("required") if isinstance(form_config.get("required"), list) else []

    properties = schema.get("properties") if isinstance(schema, dict) else {}
    values: Dict[str, Any] = {}
    if isinstance(properties, dict) and properties:
        for key, spec in properties.items():
            if not isinstance(spec, dict):
                continue
            label = f"{key}{' *' if key in required else ''}"
            default = defaults.get(key)
            enum = spec.get("enum") if isinstance(spec.get("enum"), list) else None
            field_type = spec.get("type")
            if enum:
                selected_value = default if default in enum else enum[0]
                values[key] = st.selectbox(label, enum, index=enum.index(selected_value))
            elif field_type == "boolean":
                values[key] = st.checkbox(label, value=bool(default) if default is not None else False)
            elif field_type == "integer":
                values[key] = int(st.number_input(label, value=int(default) if default is not None else 0, step=1))
            elif field_type == "number":
                values[key] = float(st.number_input(label, value=float(default) if default is not None else 0.0))
            else:
                values[key] = st.text_input(label, value=str(default) if default is not None else "")
    else:
        st.info("No schema properties available for this user input.")

    comment = st.text_area("Comment", value="", height=120, help="Optional note for this input submission.")
    if st.button("Submit input", type="primary", disabled=not run_id.strip()):
        response_payload = {
            "schema_version": form_config.get("schema_version", "1.0"),
            "form_id": form_id,
            "values": values,
            "comment": comment or "",
        }
        resp = client.resume_run(
            run_id.strip(),
            decision="APPROVED",
            approval_payload={},
            comment=None,
            user_input_response=response_payload,
        )
        if resp.ok:
            st.success(f"User input submitted for run: {run_id.strip()}")
            _append_history(run_id.strip())
            st.rerun()
        else:
            st.error(f"Failed to submit user input: {resp.error or resp.body}")


def main() -> None:
    st.set_page_config(page_title="master platform", layout="wide")
    settings = load_settings()
    observability_root = _observability_root()
    api_base = _api_base_url(settings)
    client = ApiClient(api_base)

    st.sidebar.header("Navigation")
    page = st.sidebar.radio("Section", ["Home", "Run", "Approvals", "User Inputs"])
    st.sidebar.caption(f"API base: {api_base}")

    st.session_state.setdefault("run_history", [])

    products_resp = client.list_products()
    if not products_resp.ok or not products_resp.body:
        st.error(f"Cannot load products: {products_resp.error or 'Unknown error'}")
        return

    products = sorted(products_resp.body["data"]["products"], key=lambda p: p["name"])

    if page == "Home":
        _render_product_summary(products)

    elif page == "Run":
        st.subheader("Trigger a flow")
        if not products:
            st.info("No enabled products discovered.")
            return
        prod = st.selectbox("Product", [prod["name"] for prod in products])
        product_record = _get_product_record(products, prod)
        product_config = _get_product_config(product_record)
        flows_resp = client.list_flows(prod)
        if not flows_resp.ok or not flows_resp.body:
            st.warning(f"Unable to get flows for '{prod}': {flows_resp.error or flows_resp.body}")
            flows = []
        else:
            flows = sorted(flows_resp.body["data"]["flows"])

        if not flows:
            st.info(f"No flows defined for {prod}.")
            return

        flow = st.selectbox("Flow", flows)
        file_refs: List[Dict[str, Any]] = []
        input_spec = _resolve_input_spec(product_config)
        allowed_types = input_spec.get("allowed_types") or []
        if isinstance(allowed_types, list):
            allowed_types = [str(ext).lower().lstrip(".") for ext in allowed_types if str(ext).strip()]
        else:
            allowed_types = []
        inputs_enabled = bool(input_spec.get("enabled", bool(allowed_types)))
        max_files = input_spec.get("max_files")
        files_field = input_spec.get("files_field") or "files"
        upload_id_field = input_spec.get("upload_id_field") or "upload_id"
        dataset_field = input_spec.get("dataset_field")
        upload_key = f"{prod}_upload_id"
        items_key = f"{prod}_upload_items"

        if inputs_enabled and allowed_types:
            st.markdown("### Upload files")
            uploaded = st.file_uploader(
                "Attach data files",
                type=allowed_types,
                accept_multiple_files=(max_files is None or max_files != 1),
            )
            include_uploads = st.checkbox("Include uploaded files in payload", value=True)
            if uploaded and include_uploads:
                upload_id = st.session_state.get(upload_key)
                if not upload_id:
                    upload_id = str(int(time.time()))
                    st.session_state[upload_key] = upload_id
                file_refs, items = _save_uploaded_files(
                    uploaded,
                    upload_id=upload_id,
                )
                if items:
                    _write_inputs_to_uploads(
                        observability_root,
                        product=prod,
                        upload_id=upload_id,
                        items=items,
                    )
                    st.caption(f"Files staged for upload {upload_id}.")
                if file_refs:
                    st.code(_pretty({files_field: file_refs}), language="json")
                st.session_state[items_key] = items

        payload: Dict[str, Any] = {}
        ok = True
        intent_spec = _resolve_intent_spec(product_config)
        intent_enabled = bool(intent_spec.get("enabled", False))
        if intent_enabled:
            intent_field = str(intent_spec.get("field") or "prompt")
            intent_label = intent_spec.get("label") or "Instructions"
            intent_help = intent_spec.get("help") or "Optional guidance for the analysis."
            intent_default = intent_spec.get("default") or ""
            instructions = st.text_area(
                intent_label,
                value=intent_default,
                height=140,
                help=intent_help,
            )
            payload[intent_field] = instructions.strip() if instructions else ""
        else:
            payload_key = f"{prod}_payload_json"
            if payload_key not in st.session_state:
                st.session_state[payload_key] = "{}"
            example_key = f"{prod}_example_loaded"
            if st.button("Load Example", type="secondary"):
                st.session_state[example_key] = True
                if prod == "hello_world":
                    st.session_state[payload_key] = _pretty({"keyword": "Hello from the demo"})
                else:
                    st.session_state[payload_key] = _pretty(
                        {
                            "dataset": "visual_insights_input.csv",
                            "prompt": "Summarize key trends and highlight anomalies.",
                            "files": [{"name": "visual_insights_input.csv", "file_type": "csv"}],
                            "upload_id": "demo_upload_1",
                        }
                    )
            payload_text = st.text_area("Payload (JSON)", value=st.session_state[payload_key], height=220)
            st.session_state[payload_key] = payload_text
            ok, payload, err = _safe_json_loads(payload_text)
            if not ok:
                st.error(f"Invalid JSON: {err}")

        if file_refs:
            payload.setdefault(files_field, file_refs)
            payload[upload_id_field] = st.session_state.get(upload_key)
            if dataset_field and dataset_field not in payload:
                csv_name = next((f["name"] for f in file_refs if f["file_type"] == "csv"), None)
                if csv_name:
                    payload[dataset_field] = csv_name
            st.markdown("### Payload preview")
            st.code(_pretty(payload), language="json")

        if flow and st.button("Run flow", disabled=(not ok)):
            resp = client.run_flow(prod, flow, payload)
            st.code(_pretty(resp.body or resp.error), language="json")
            if resp.ok and resp.body:
                run_id = resp.body.get("data", {}).get("run_id")
                if run_id:
                    st.success(f"Run started: {run_id}")
                    _append_history(run_id)
                    _materialize_run_dirs(observability_root, product=prod, run_id=run_id)
                    st.session_state["last_run_id"] = run_id
                    st.session_state["last_run_status"] = resp.body.get("data", {}).get("status")
                    st.session_state["last_run_product"] = prod
                    st.session_state["last_run_flow"] = flow

        pending_status = st.session_state.get("last_run_status")
        if pending_status in {"PENDING_USER_INPUT", "NEEDS_USER_INPUT"}:
            run_id = st.session_state.get("last_run_id")
            flow_name = st.session_state.get("last_run_flow") or flow
            flow_def = _load_flow_definition(prod, flow_name) or {}
            user_input_step = None
            for step in flow_def.get("steps", []):
                if isinstance(step, dict) and step.get("type") == "user_input":
                    user_input_step = step
                    break
            if not user_input_step:
                st.info("Run is waiting for user input, but no user_input step metadata is available.")
            else:
                params = user_input_step.get("params") if isinstance(user_input_step.get("params"), dict) else {}
                form_id = params.get("form_id") or "user_input"
                prompt = params.get("prompt") or params.get("title") or "Provide input"
                input_type = params.get("input_type") or ("text" if params.get("mode") == "free_text_input" else "select")
                choices = params.get("choices") if isinstance(params.get("choices"), list) else None
                defaults = params.get("defaults") if isinstance(params.get("defaults"), dict) else {}
                required = params.get("required") if isinstance(params.get("required"), list) else []
                schema = params.get("schema") if isinstance(params.get("schema"), dict) else {}
                properties = schema.get("properties") if isinstance(schema.get("properties"), dict) else {}

                st.markdown("### User input required")
                st.write(prompt)
                values: Dict[str, Any] = {}
                if input_type == "select" and choices:
                    labels = [c.get("label") or c.get("value") for c in choices]
                    default_val = defaults.get("value")
                    default_idx = labels.index(default_val) if default_val in labels else 0
                    selection = st.selectbox("Select value", labels, index=default_idx)
                    values["value"] = selection
                elif properties:
                    for key, spec in properties.items():
                        if not isinstance(spec, dict):
                            continue
                        label = f"{key}{' *' if key in required else ''}"
                        enum = spec.get("enum") if isinstance(spec.get("enum"), list) else None
                        default = defaults.get(key)
                        if enum:
                            selected_value = default if default in enum else enum[0]
                            values[key] = st.selectbox(label, enum, index=enum.index(selected_value))
                        elif spec.get("type") == "number":
                            values[key] = float(st.number_input(label, value=float(default or 0.0)))
                        elif spec.get("type") == "integer":
                            values[key] = int(st.number_input(label, value=int(default or 0), step=1))
                        elif spec.get("type") == "boolean":
                            values[key] = st.checkbox(label, value=bool(default) if default is not None else False)
                        else:
                            values[key] = st.text_input(label, value=str(default) if default is not None else "")
                else:
                    values["text"] = st.text_area("Response", value=str(defaults.get("text", "")), height=140)

                comment = st.text_area("Comment", value="", height=80)
                if st.button("Submit input", type="primary", disabled=not run_id):
                    response_payload = {
                        "schema_version": params.get("schema_version", "1.0"),
                        "form_id": form_id,
                        "values": values,
                        "comment": comment or "",
                    }
                    resp = client.resume_run(
                        run_id,
                        decision="APPROVED",
                        approval_payload={},
                        comment=None,
                        user_input_response=response_payload,
                    )
                    if resp.ok:
                        st.success("User input submitted. Refreshing run status...")
                        st.session_state["last_run_status"] = resp.body.get("data", {}).get("status") if resp.body else None
                        st.rerun()
                    else:
                        st.error(f"Failed to submit user input: {resp.error or resp.body}")

    elif page == "Approvals":
        _render_approvals(client)

    elif page == "User Inputs":
        _render_user_inputs(client)
        st.divider()
        _render_run_history(observability_root=observability_root)


if __name__ == "__main__":
    main()
